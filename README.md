네트워크 플로우(Network Flow)
네트워크 플로우는 특정지점에서 다른지점으로 데이터가 얼마나 많이 흐르고 있는가를 측정하는 알고리즘이다.
![](C:\KakaoTalk_20220429_052905977_04.jpg)
이러한 알고리즘은 교통체증, 네트워크 데이터 전송등의 다양한 분야에 활용되고 있다.
예를들어 A에서 B로 가는 길의 폭이 8, B에서 C로 가는 폭이 3이라고 해봅시다. 이러한 상황에서 길을 건너는데 1초가 걸린다고 가정해봅시다.
이때 A에서 B로 사람 8명을 보냈다고 했을 때 1초가 지난 뒤의 상황은 이럴 것입니다.
![](C:\KakaoTalk_20220429_052905977_03.jpg)
따라서 위와 같이 1초에 3명씩 A에서 B로 보내야 막힘 없이 안정적으로 보낼 수가 있습니다. 위와 같은 표현 방식은 유량/용량입니다.
![](C:\KakaoTalk_20220429_052905977_02.jpg)
위와 같이 A에서 B로 갈수있는 용량은 8, B에서 C로 갈수 있는 용량은 6, C에서 D로 갈수 있는 용량은 7이라고 해봅시다. 이때 A에서 D로 최대한 많은 유량을 보내려고 할때 가장 합리적인 양은

위와 같이 6이 될것입니다.
이를 네트워크 유량 문제 라고 합니다.
네트워크 유량문제란 각 경로로 보낼 수 있는 초당 최대 용량은
- 경로에 포함된 간선 중 가장 용량이 작은 간선에 의해 결정됩니다.
  -예) [s,a,c,t] : min(16,20,10) = 10
  s에서 t로 보낼 수 있는 초당 최대용량은 10MB이 됩니다.

만약, 여러 패킷으로 잘라서 여러개의 경로로 동시에 보낼 수 있다면?

-s에서 초당 최대 17MB까지 t로 전송 가능할 것 입니다
![](C:\KakaoTalk_20220429_052905977_01.jpg)

유량 네트워크의 속성
정의)
-c(u,v): 정점 u에서 v로 가는 간선의 용량(capacity)
-f(u,v): 정점 u에서 v로 실제 흐르는 유량(flow)

유량 네트워크가 만족해야하는 세가지 속성
- 용량 제한 속성: f(u,v) <= c(u,v)
- 유량의 대칭성: f(u,v) = -f(v,u)

u에서 v로 유량이 흐르면 v에서 u로 음수의 유량이 흐르는 것과 동일합니다.

유량의 보존: 각 정점에서 들어오는 유량과 나가는 유량은 같습니다.

포드 풀커슨 알고리즘 : Ford-Fulkerson Algorithm

소스(source)노드에서 시작해서 싱크(sink)노드로 도착하는 유량
-유량 네트워크의 모든 간선의 유량을 0으로 초기화
-소스에서 싱크로 유량을 더 보낼 수 있는 경로를 찾아 유량 보내기를 반복
![](C:\KakaoTalk_20220429_052905977.jpg)
위의 점선을 따라 유량을 보내 보면 최대 1을 보낼수 있을 것입니다.
밑의 선을 따라서는 최대 2을 보낼 수 있을 것입니다.

포드 풀커슨 알고리즘은 증강경로가 나오지 않을 때까지 유량을 그리디하게 흘려주는 방식입니다.

포드 풀커슨 알고리즘을 정리하자면,

1.네트워크에 존재하는 모든 간선의 유량을 0 으로 초기화하고, 역방향 간선의 유량도 0 으로 초기화합니다.
2.소스에서 싱크로 갈 수 있는, 잔여 용량이 남은 경로를 DFS 로 탐색합니다.
3.해당 경로에 존재하는 간선들의 잔여 용량 중, 가장 작은 값을 유량으로 흘려보냅니다.
4.해당 유량에 음수값을 취해, 역방향 간선에도 흘려보냅니다. (유량 상쇄)
5.더 이상 잔여 용량이 남은 경로가 존재하지 않을때까지 반복합니다.

 여기서 유량 상쇄란, 모든 경로에 기존에 존재하는 간선들과 반대되는 방향의 간선을 추가한 뒤,
각 간선으로 유량을 흘려보냈을 때 반대 방향의 간선으로도 음의 유량을 흘려보냄으로써 유량을 상쇄시키는 것을 의미합니다.
물론, 실제로는 불가능한 얘기이지만, 음의 유량을 기록함으로써 잔여 용량을 남겨 추가적인 경로를 탐색할 수 있도록 하기 위한 작업입니다.

예를 들어, a → b 의 간선이 존재하며, 유량 f(a, b) 은 1 , 용량 c(a, b) 은 1 이라면

역간선 b → a 의 유량 f(b, a) 은 기존 간선의 방향과 반대이므로 - 1 이 되며,

용량 c(b, a) 은 실제 존재하는 간선이 아니므로 0 이 됩니다.
따라서, 역간선 b → a 의 잔여 용량 r(b, a) 은, c(b,a) - f(b, a) = 0 - ( - 1 ) = 1 이 됩니다.
즉, 역간선 b → a 로 1 의 유량을 추가적으로 흘려보낼 수 있게 됩니다.


![](C:\다운로드.png)
포드-풀커슨 알고리즘 (Ford-Fulkerson Algorithm)을 다시 이해해 보겠습니다.


위 그림은, 네트워크에 존재하는 모든 간선의 유량을 0 으로 초기화하고 역방향 간선의 유량도 0 으로 초기화한 뒤
DFS 를 사용해 소스에서 싱크로 갈 수 있는 경로 중 하나인  S → a → b → T 경로를 탐색하고
해당 경로에 존재하는 간선들의 잔여 용량 중 가장 작은 값인 1 을 유량으로 흘려보낸 
해당 유량에 음수값을 취해 역방향 간선에도 -1 을 흘려보낸 결과입니다.
즉, b 에서 a 로 1 만큼의 유량을 추가로 흘려보낼 수 있는 것을 알 수 있습니다.
따라서, s → b → a → t 경로에 존재하는 간선들의 잔여 용량을 확인한 뒤 잔여 용량 중 가장 작은 값인 1 을 유량으로 흘려보냅니다.

![](C:\img.png)
결과적으로, 간선 (a, b) 와 (b, a) 가 상쇄되므로, 아래와 같은 정답이 도출되는 것을 알 수 있습니다.

포드-풀커슨 알고리즘에는 문제점이 있습니다.

증가경로 한개당 플로우 1밖에 보낼 수 없습니다.
즉  DFS를 플로우 수만큼 사용해야하는 경우가 생기게됩니다.
만약 플로우 수가 크다면 답이 없습니다.
그래서 포드풀커슨의 시간복잡도는 O((V+E)F)인데 보통 에지수가 더 많을테니 O(EF)로 나타내게 됩니다.
이를 해결하기 위해서는 간단하게 DFS부분을 BFS로만 바꿔주면 해결이 됩니다.

이러한 알고리즘은 에드먼드-카프 알고리즘이라고 합니다.
시간복잡도는 O(VE2) or O(EF) 중 작은 것이라고 합니다.
